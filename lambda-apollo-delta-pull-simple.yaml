AWSTemplateFormatVersion: '2010-09-09'
Description: 'Apollo Delta Pull Lambda Function with Rate Limiting'

Parameters:
  Environment:
    Type: String
    Default: dev
    AllowedValues: [dev, staging, prod]
    Description: Environment name
  
  RawBucket:
    Type: String
    Description: S3 bucket for raw data storage
    Default: thera-raw
  
  BronzeBucket:
    Type: String
    Description: S3 bucket for bronze layer data
    Default: thera-bronze
  
  ApolloSecretName:
    Type: String
    Description: Secrets Manager secret name for Apollo API key
    Default: thera/apollo/api-key

Resources:
  # DynamoDB table for quota tracking
  ApolloQuotaTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub '${Environment}-apollo-quota'
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: id
          AttributeType: S
      KeySchema:
        - AttributeName: id
          KeyType: HASH
      TimeToLiveSpecification:
        AttributeName: ttl
        Enabled: true
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true

  # IAM Role for Lambda
  ApolloDeltaPullRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${Environment}-apollo-delta-pull-role'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: ApolloDeltaPullPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              # S3 permissions
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:PutObject
                  - s3:DeleteObject
                Resource:
                  - !Sub 'arn:aws:s3:::${RawBucket}/*'
                  - !Sub 'arn:aws:s3:::${BronzeBucket}/*'
              
              # DynamoDB permissions
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:PutItem
                  - dynamodb:UpdateItem
                  - dynamodb:DeleteItem
                  - dynamodb:Query
                  - dynamodb:Scan
                Resource:
                  - !GetAtt ApolloQuotaTable.Arn
              
              # Secrets Manager permissions
              - Effect: Allow
                Action:
                  - secretsmanager:GetSecretValue
                Resource:
                  - !Sub 'arn:aws:secretsmanager:${AWS::Region}:${AWS::AccountId}:secret:${ApolloSecretName}*'
              
              # CloudWatch permissions
              - Effect: Allow
                Action:
                  - cloudwatch:PutMetricData
                Resource: '*'

  # Lambda Function
  ApolloDeltaPullFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${Environment}-apollo-delta-pull'
      Runtime: python3.12
      Handler: lambda-apollo-delta-pull.lambda_handler
      Role: !GetAtt ApolloDeltaPullRole.Arn
      Timeout: 900  # 15 minutes
      MemorySize: 512
      Environment:
        Variables:
          APOLLO_QUOTA_TABLE: !Sub '${Environment}-apollo-quota'
          RAW_BUCKET: !Ref RawBucket
          BRONZE_BUCKET: !Ref BronzeBucket
          APOLLO_SECRET_NAME: !Ref ApolloSecretName
          AWS_REGION: !Ref AWS::Region
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          from datetime import datetime, timedelta
          import time
          
          def lambda_handler(event, context):
              """
              Apollo Delta Pull Lambda Function
              Fetches company data from Apollo API with rate limiting
              """
              print(f"Starting Apollo Delta Pull: {event}")
              
              # Initialize AWS clients
              dynamodb = boto3.resource('dynamodb')
              s3 = boto3.client('s3')
              secrets_manager = boto3.client('secretsmanager')
              cloudwatch = boto3.client('cloudwatch')
              
              # Get environment variables
              quota_table_name = os.environ['APOLLO_QUOTA_TABLE']
              raw_bucket = os.environ['RAW_BUCKET']
              bronze_bucket = os.environ['BRONZE_BUCKET']
              secret_name = os.environ['APOLLO_SECRET_NAME']
              
              try:
                  # Get Apollo API key from Secrets Manager
                  secret_response = secrets_manager.get_secret_value(SecretId=secret_name)
                  secret_data = json.loads(secret_response['SecretString'])
                  apollo_api_key = secret_data['apollo_api_key']
                  
                  # Initialize quota table
                  quota_table = dynamodb.Table(quota_table_name)
                  
                  # Check rate limits
                  if not check_rate_limits(quota_table):
                      return {
                          'statusCode': 429,
                          'body': json.dumps('Rate limit exceeded')
                      }
                  
                  # Fetch data from Apollo API
                  companies_data = fetch_apollo_data(apollo_api_key)
                  
                  # Store raw data in S3
                  raw_key = f"apollo/date={datetime.now().strftime('%Y-%m-%d')}/companies.jsonl"
                  s3.put_object(
                      Bucket=raw_bucket,
                      Key=raw_key,
                      Body=json.dumps(companies_data, default=str)
                  )
                  
                  # Process and store bronze data
                  bronze_data = process_bronze_data(companies_data)
                  bronze_key = f"bronze_apollo_companies/date={datetime.now().strftime('%Y-%m-%d')}/companies.parquet"
                  # Note: In a real implementation, you'd convert to Parquet format
                  s3.put_object(
                      Bucket=bronze_bucket,
                      Key=bronze_key,
                      Body=json.dumps(bronze_data, default=str)
                  )
                  
                  # Update quota tracking
                  update_quota_tracking(quota_table, len(companies_data))
                  
                  # Send metrics to CloudWatch
                  cloudwatch.put_metric_data(
                      Namespace='TheraPipeline/Apollo',
                      MetricData=[
                          {
                              'MetricName': 'ItemsFetched',
                              'Value': len(companies_data),
                              'Unit': 'Count'
                          },
                          {
                              'MetricName': 'ApiCallsUsed',
                              'Value': 1,
                              'Unit': 'Count'
                          }
                      ]
                  )
                  
                  return {
                      'statusCode': 200,
                      'body': json.dumps({
                          'message': 'Apollo data fetched successfully',
                          'items_count': len(companies_data),
                          'raw_key': raw_key,
                          'bronze_key': bronze_key
                      })
                  }
                  
              except Exception as e:
                  print(f"Error in Apollo Delta Pull: {str(e)}")
                  return {
                      'statusCode': 500,
                      'body': json.dumps(f'Error: {str(e)}')
                  }
          
          def check_rate_limits(quota_table):
              """Check if we can make API calls within rate limits"""
              now = datetime.now()
              minute_key = f"minute_{now.strftime('%Y-%m-%d-%H-%M')}"
              hour_key = f"hour_{now.strftime('%Y-%m-%d-%H')}"
              day_key = f"day_{now.strftime('%Y-%m-%d')}"
              
              # Check minute limit (50 calls)
              minute_response = quota_table.get_item(Key={'id': minute_key})
              minute_count = minute_response.get('Item', {}).get('count', 0)
              if minute_count >= 50:
                  return False
              
              # Check hour limit (200 calls)
              hour_response = quota_table.get_item(Key={'id': hour_key})
              hour_count = hour_response.get('Item', {}).get('count', 0)
              if hour_count >= 200:
                  return False
              
              # Check day limit (600 calls)
              day_response = quota_table.get_item(Key={'id': day_key})
              day_count = day_response.get('Item', {}).get('count', 0)
              if day_count >= 600:
                  return False
              
              return True
          
          def fetch_apollo_data(api_key):
              """Fetch company data from Apollo API"""
              # This is a simplified example - in reality you'd implement the full Apollo API integration
              headers = {
                  'Content-Type': 'application/json',
                  'X-Api-Key': api_key
              }
              
              # Mock data for demonstration
              return [
                  {
                      'id': '1',
                      'name': 'Example Company 1',
                      'domain': 'example1.com',
                      'industry': 'Technology',
                      'founded_year': 2020,
                      'employees': 50
                  },
                  {
                      'id': '2',
                      'name': 'Example Company 2',
                      'domain': 'example2.com',
                      'industry': 'Healthcare',
                      'founded_year': 2019,
                      'employees': 100
                  }
              ]
          
          def process_bronze_data(companies_data):
              """Process raw data into bronze layer format"""
              bronze_data = []
              for company in companies_data:
                  bronze_item = {
                      'company_id': company['id'],
                      'company_name': company['name'],
                      'domain': company['domain'],
                      'industry': company['industry'],
                      'founded_year': company['founded_year'],
                      'employee_count': company['employees'],
                      'created_at': datetime.now().isoformat(),
                      'updated_at': datetime.now().isoformat()
                  }
                  bronze_data.append(bronze_item)
              return bronze_data
          
          def update_quota_tracking(quota_table, items_count):
              """Update quota tracking in DynamoDB"""
              now = datetime.now()
              minute_key = f"minute_{now.strftime('%Y-%m-%d-%H-%M')}"
              hour_key = f"hour_{now.strftime('%Y-%m-%d-%H')}"
              day_key = f"day_{now.strftime('%Y-%m-%d')}"
              
              # Update minute count
              quota_table.update_item(
                  Key={'id': minute_key},
                  UpdateExpression='ADD #count :val SET #ttl = :ttl',
                  ExpressionAttributeNames={'#count': 'count', '#ttl': 'ttl'},
                  ExpressionAttributeValues={':val': 1, ':ttl': int((now + timedelta(minutes=1)).timestamp())}
              )
              
              # Update hour count
              quota_table.update_item(
                  Key={'id': hour_key},
                  UpdateExpression='ADD #count :val SET #ttl = :ttl',
                  ExpressionAttributeNames={'#count': 'count', '#ttl': 'ttl'},
                  ExpressionAttributeValues={':val': 1, ':ttl': int((now + timedelta(hours=1)).timestamp())}
              )
              
              # Update day count
              quota_table.update_item(
                  Key={'id': day_key},
                  UpdateExpression='ADD #count :val SET #ttl = :ttl',
                  ExpressionAttributeNames={'#count': 'count', '#ttl': 'ttl'},
                  ExpressionAttributeValues={':val': 1, ':ttl': int((now + timedelta(days=1)).timestamp())}
              )
      Tags:
        - Key: Environment
          Value: !Ref Environment
        - Key: Service
          Value: thera-pipeline
        - Key: Component
          Value: apollo-delta-pull

  # CloudWatch Log Group
  ApolloDeltaPullLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/aws/lambda/${Environment}-apollo-delta-pull'
      RetentionInDays: 14

  # CloudWatch Alarms
  ApolloDeltaPullErrorAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub '${Environment}-apollo-delta-pull-errors'
      AlarmDescription: 'Apollo Delta Pull Lambda errors'
      MetricName: Errors
      Namespace: AWS/Lambda
      Statistic: Sum
      Period: 300
      EvaluationPeriods: 1
      Threshold: 1
      ComparisonOperator: GreaterThanOrEqualToThreshold
      Dimensions:
        - Name: FunctionName
          Value: !Ref ApolloDeltaPullFunction
      TreatMissingData: notBreaching

  ApolloDeltaPullDurationAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub '${Environment}-apollo-delta-pull-duration'
      AlarmDescription: 'Apollo Delta Pull Lambda duration too high'
      MetricName: Duration
      Namespace: AWS/Lambda
      Statistic: Average
      Period: 300
      EvaluationPeriods: 2
      Threshold: 600000  # 10 minutes in milliseconds
      ComparisonOperator: GreaterThanThreshold
      Dimensions:
        - Name: FunctionName
          Value: !Ref ApolloDeltaPullFunction
      TreatMissingData: notBreaching

  # Custom metrics for business logic
  ApolloItemsFetchedAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub '${Environment}-apollo-items-fetched-low'
      AlarmDescription: 'Apollo items fetched count is low'
      MetricName: ItemsFetched
      Namespace: TheraPipeline/Apollo
      Statistic: Sum
      Period: 3600  # 1 hour
      EvaluationPeriods: 1
      Threshold: 10
      ComparisonOperator: LessThanThreshold
      TreatMissingData: notBreaching

Outputs:
  ApolloDeltaPullFunctionArn:
    Description: 'ARN of the Apollo Delta Pull Lambda function'
    Value: !GetAtt ApolloDeltaPullFunction.Arn
    Export:
      Name: !Sub '${Environment}-ApolloDeltaPullFunctionArn'
  
  ApolloDeltaPullRoleArn:
    Description: 'ARN of the Apollo Delta Pull IAM role'
    Value: !GetAtt ApolloDeltaPullRole.Arn
    Export:
      Name: !Sub '${Environment}-ApolloDeltaPullRoleArn'
